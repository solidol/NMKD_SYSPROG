<!DOCTYPE html>
<html>
<head>
	<title>Лекція № 2</title>
	<style type="text/css">
		h1{
			text-align: center;
			font-size: 16pt;
			font-weight: bold;
			text-transform: uppercase;
		}
		h2{
			text-align: center;
			font-size: 14pt;
			font-weight: bold;
		}
		p, li{
			font-size: 14pt;
		}
		body{
			padding-left: 15%;
			padding-right: 15%;
		}
		.paper{
			max-width: 210mm;
		}
		.paper p{
			text-align: justify;
			text-indent: 1.25cm;
		}
		.topfield{
			color: grey;
			font-size: 14px;
			text-align: center;
			width: 100%;
		}
	</style>
</head>
<body>
	<div class="paper">
		<div class="topfield">Системне програмування</div>
		<h1>Лекція № 2. Вирази. Оператори, операції, операнди</h1>
		<h2>Вирази</h2>
		<p>
			Вираз будується з однієї або декількох операцій. Об'єкти цих операцій називаються операндами. Операції бувають унарні - які діють на один операнд - наприклад унарний мінус (-x) і бінарні - які діють на два операнда (додавання і т.п. - x + y).
		</p>
		<p>
			Обчислення виразу полягає у виконанні однієї або декількох опера¬цій, що призводять до результату. Тип даних вираження зазвичай визначається типами його операндів. Коли в вираженні присутні більше одного типу даних, то відбувається перетворення типу відповідно до певними правилами.
		</p>
		<p>
			Вираз, в якому беруть участь дві або більше операції, називається складовим (наприклад, x + y-z). Порядок застосування операцій визначається пріоритетом операції (яка операція виконується раніше, а яка пізніше) і її асоціативністю (зліва направо вона виконується або справа наліво).
		</p>
		<p>
			Найпростіше вираз - просто операнд без операції - тобто константа або змінна. Наприклад 3.14159 або index. Тип виразу відповідає типу даної константи або змінної.

		</p>



		<h2>Арифметичні операції</h2>

		<p>
			Бінарними арифметичними операціями є +, -, *, / а також операція взяття залишку%. Операції *, / і% мають більш високий пріоритет, ніж + і - (як і в Паскалі). Наприклад, x + y * z трактується як x + (y * z), що природно. Якщо потрібно змінити порядок обчислень - то потрібно, як і в Паскалі, використовувати дужки. Є дві відмінності від Паскаля:
		</p>
		<ol>
			<li> Операція % бере залишок (тобто 22 % 6 буде 4) і може бути застосована тільки до цілих</li>
			<li> Якщо операція / застосовується до цілим, то результатом ділення буде теж ціле, а залишок відкидається (22/6 буде 3)</li>
		</ol>
		<p>
			Арифметичні операції з однаковим пріоритетом виконуються зліва направо.
			Є й унарні операції + і -. Їх пріоритет вище, ніж у бінарних -
			-x * y означає (-x) * y a ні - (x * y).
		</p>
		<p>
			Слід зауважити, що в результаті виконання арифметичних операцій можна вийти за діапазон типу. Наприклад
		</p>
		<p>
			unsigned char uc = 32, uc1 = 10;
			uc = uc * uc1;
			В результаті uc має отримати значення 320, а верхній діапазон unsigned char, як відомо, дорівнює 255. Що при цьому буде - залежить від машини.


			Операції відносини і логічні операції.

			Зведена таблиця з пріоритетами
		</p>
		<table class="wikitable">

			<tbody><tr>
				<th> Приоритет
				</th>
				<th> Оператор
				</th>
				<th> Описание
				</th>
				<th> Ассоциативность
				</th></tr>
				<tr>
					<th rowspan="6"> 1
					</th>
					<td> <code>++</code> <code>--</code>
					</td>
					<td> Суффиксные/постфиксные инкремент и декремент
					</td>
					<td rowspan="6"> Слева направо
					</td>
				</tr>
				<tr>
					<td> <code>()</code>
					</td>
					<td> Вызов функции
					</td>
				</tr>
				<tr>
					<td> <code>[]</code>
					</td>
					<td> Обращение к элементу массива
					</td>
				</tr>
				<tr>
					<td> <code>.</code>
					</td>
					<td> Обращение к члену структуры или объединения
					</td>
				</tr>
				<tr>
					<td> <code>−&gt;</code>
					</td>
					<td> Обращение к члену структуры или объединения через указатель
					</td>
				</tr>
				<tr>
					<td> <code>(<i>type</i>){<i>list</i>}</code>
					</td>
					<td> Составной литерал<span class="t-mark-rev t-since-c99">(C99)</span>
					</td>
				</tr>
				<tr>
					<th rowspan="8"> 2
					</th>
					<td> <code>++</code> <code>--</code>
					</td>
					<td> Префиксные инкремент и декремент
					</td>
					<td rowspan="8"> Справа налево
					</td>
				</tr>
				<tr>
					<td> <code>+</code> <code>−</code>
					</td>
					<td> Унарные плюс и минус
					</td>
				</tr>
				<tr>
					<td> <code>!</code> <code>~</code>
					</td>
					<td> Логическое НЕ и побитовое НЕ
					</td>
				</tr>
				<tr>
					<td> <code>(<i>type</i>)</code>
					</td>
					<td> Приведение типа
					</td>
				</tr>
				<tr>
					<td> <code>*</code>
					</td>
					<td> Разыменование
					</td>
				</tr>
				<tr>
					<td> <code>&amp;</code>
					</td>
					<td> Взятие адреса
					</td>
				</tr>
				<tr>
					<td> <code>sizeof</code>
					</td>
					<td> Размер
					</td>
				</tr>
				<tr>
					<td> <code>_Alignof</code>
					</td>
					<td> Выравнивание<span class="t-mark-rev t-since-c11">(C11)</span>
					</td>
				</tr>
				<tr>
					<th> 3
					</th>
					<td> <code>*</code> <code>/</code> <code>%</code>
					</td>
					<td> Умножение, деление и остаток
					</td>
					<td rowspan="11"> Слева направо
					</td>
				</tr>
				<tr>
					<th> 4
					</th>
					<td> <code>+</code> <code>−</code>
					</td>
					<td> Сложение и вычитание
					</td>
				</tr>
				<tr>
					<th> 5
					</th>
					<td> <code>&lt;&lt;</code> <code>&gt;&gt;</code>
					</td>
					<td> Побитовые левый сдвиг и правый сдвиг
					</td>
				</tr>
				<tr>
					<th rowspan="2"> 6
					</th>
					<td> <code>&lt;</code> <code>&lt;=</code>
					</td>
					<td> Для операторов сравнения &lt; и ≤ соответственно
					</td>
				</tr>
				<tr>
					<td> <code>&gt;</code> <code>&gt;=</code>
					</td>
					<td> Для операторов сравнения &gt; и ≥ соответственно
					</td>
				</tr>
				<tr>
					<th> 7
					</th>
					<td> <code>==</code> <code>!=</code>
					</td>
					<td> Для сравнений = и ≠ соответственно
					</td>
				</tr>
				<tr>
					<th> 8
					</th>
					<td> <code>&amp;</code>
					</td>
					<td> Побитовое И
					</td>
				</tr>
				<tr>
					<th> 9
					</th>
					<td> <code>^</code>
					</td>
					<td> Побитовое XOR (исключающее или)
					</td>
				</tr>
				<tr>
					<th> 10
					</th>
					<td> <code>|</code>
					</td>
					<td> Побитовое ИЛИ (включающее или)
					</td>
				</tr>
				<tr>
					<th> 11
					</th>
					<td> <code>&amp;&amp;</code>
					</td>
					<td> Логическое И
					</td>
				</tr>
				<tr>
					<th> 12
					</th>
					<td> <code>||</code>
					</td>
					<td> Логическое ИЛИ
					</td>
				</tr>
				<tr>
					<th> 13
					</th>
					<td> <code>?:</code>
					</td>
					<td> Тернарное условие
					</td>
					<td rowspan="6"> Справа налево
					</td>
				</tr>
				<tr>
					<th rowspan="5"> 14
					</th>
					<td> <code>=</code>
					</td>
					<td> Простое присваиваиние
					</td>
				</tr>
				<tr>
					<td> <code>+=</code> <code>−=</code>
					</td>
					<td> Присваивание через сумму и разность
					</td>
				</tr>
				<tr>
					<td> <code>*=</code> <code>/=</code> <code>%=</code>
					</td>
					<td> Присваивание через произведение, частное и остаток
					</td>
				</tr>
				<tr>
					<td> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code>
					</td>
					<td> Присваивание через левый сдвиг и правый сдвиг
					</td>
				</tr>
				<tr>
					<td> <code>&amp;=</code> <code>^=</code> <code>|=</code>
					</td>
					<td> Присваивание через побитовые И, исключающее ИЛИ и ИЛИ
					</td>
				</tr>
				<tr>
					<th> 15
					</th>
					<td> <code>,</code>
					</td>
					<td> Запятая
					</td>
					<td> Слева направо
					</td>
				</tr></tbody></table>
				<p>
					Пріоритет операцій відносини і логічних операцій нижче, ніж у арифметичних операцій (i &lt; j + 1 трактується як i &lt; (j + 1)).
					Одним з основоположних ідейних відмінностей С і С ++ від Паскаля, так би мовити, на повсякденному рівні є те, що всі операції відносини і логічні операції повертають ціле значення -

					1 - якщо умова істинна
					0 - якщо умова помилкова

					В С немає булевского типу. Логічні операції теж оперують з цілими величинами, або з величинами, які можна перетворити в цілі (в тому числі і з плаваючою точкою). При цьому істиною вважається будь-яка нульове значення, а брехнею - нуль. Звідси ясно, що функція, яка повертає ціле або приводиться до цілого значення і взагалі будь-який вираз, що приводиться до цілого, може в С використовуватися в логічних умовах.
					Логічні операції && і || аналогічні за принципом дії паскалевская and і or. Результат && - істина (1) якщо обидва її операнда істинні (не рівні 0). результат || істина якщо хоча б один з її операндів істина. Гарантується, що операнди обчислюються зліва направо. Обчислення прекра¬щается, як тільки визначиться, чи є вираз істинним або хибним. Це означає, що для вираження
					вир1 && вир2
					вир2 НЕ буде обчислюватися, якщо значення вир1 помилково (дорівнює 0) а для вираження
					вир1 && вир2
					вир2 НЕ буде обчислюватися, якщо значення вир1 істинно (не дорівнює 0) Слід зазначити, що, на відміну від Паскаля, пріоритет && і || нижче, ніж у операцій рівності і відносини і тому якщо потрібно, наприклад, перевірити, чи потрапила змінна в діапазон від 0 до 100, то такий запис коректна
					if (i1> = 0 && i1 <= 100)
					і не вимагає додаткових дужок.
					Логічне заперечення! перетворює свій операнд в істину (1) якщо він дорівнює 0 і в брехню (0) якщо він не дорівнює нулю.
					Вираз (! Found) повертає істину, поки found дорівнює нулю.
					Можна писати if (! Found)
					а можна
					if (found == 0)
					Яким чином писати - справа програміста, але в складних виразах краще замість! явно перевіряти на рівність.
					Так само точно замість
					if (found! = 0)
					можна просто написати
					if (found)

					Операції інкремента і декремента

					В С є дві операції, призначених для зменшення і збільшення змінних. Операції інкремента ++ і декремента - дають компактну і зручну запис для збільшення або зменшення змінної на одиницю.
					Кожна така операція має дві форми: префіксних і Постфіксний. наприклад:
					int c;
					++ c; // префіксний інкремент
					c ++; // постфіксний інкремент

					В обох випадках значення з збільшиться на одиницю. Але вираз ++ з збільшує з до того, як його значення буде використано, а з ++ - після того. Коли, як в нашому прикладі, з ++ варто в операторі окремо, то різниці немає. Але якщо інкремент або декремент поставити в вираз, то різниця з'явиться:
					Якщо з одно 5 то запис x = c ++;
					еквівалентна операторам
					x = c; з = c + 1;
					і x буде дорівнює 5, а запис
					x = ++ c;
					еквівалентна операторам
					з = c + 1; x = c;
					і x буде дорівнює 6. (з дорівнюватиме 6 в обох випадках).
					Аналогічні справи з декрементом -. Він зменшує свій операнд на одиницю.
					Інкремент і декремент - це привласнення і їх операнд повинен бути lvalue.
					Тут буде помилка x = (a + b) -;
					(Значення виразу a + b - rvalue і не пов'язане з об'єктом в пам'яті) і тут теж
					++ a ++;
					(Значення, яке видає присвоювання (і в тому числі інкремент) теж не пов'язане з об'єктом в пам'яті). На відміну від операцій простого і складеного присвоювання, інкремент і декремент мають високий пріоритет - такий же, як унарний мінус або
					логічне заперечення!.

				</p>
				<p>
					<code>
						&lt;?php<br>
						phpinfo();<br>
						?&gt;<br>
					</code>
				</p>

				<h2>Контрольні питання</h2>
				<ol>
					<li>Назвіть арифметичні операції. Яка специфіка використання операції ділення?</li>
					<li>Які програмні продукти подібні до Apache ви знаєте?</li>
					<li>Для чого необхідно вкахувати <code>http://</code> перед адресою сайту?</li>

				</ol>
			</div>
		</body>
		</html>